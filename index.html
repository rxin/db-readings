<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Readings in Databases</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Readings in Databases</h1>
      </header>
      <section>

<p>A list of papers essential to understanding databases and building new data systems.</p>


<h3>Basics</h3>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/5-min-rule.pdf">The Five-Minute Rule Ten Years Later, and Other Computer Storage Rules of Thumb</a>: This paper (and the original one proposed 10 years earlier) illustrates a quantitative formula to calculate whether a data page should be cached in memory or not. It is a delight to read Jim Gray approach to an array of related problems, e.g. how big should a page size be.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/Paxos.pdf">Paxos Made Simple</a>: Paxos is a fault-tolerant distributed consensus protocol. It forms the basis of a wide variety of distributed systems. The idea is simple, but notoriously difficult to understand (perhaps due to the way the original Paxos paper was written).</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/alphasort.pdf">AlphaSort: A Cache-Sensitive Parallel External Sort</a></p>


<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Essentials of Relational Databases</h3>

<p><a href="http://mitpress.mit.edu/books/chapters/0262693143chapm2.pdf">Anatomy of a Database System</a>: Joe Hellerstein's great overview of relational database systems. This essay walks readers through all components essential to relational database systems.

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/Relational-Model-Codd.pdf">A  Relational Model of Data for Large Shared Data Banks</a>: Codd's argument for data independence (from 1970), a fundamental concept in relational databases. Despite the current NoSQL trend, I believe ideas from this paper are becoming increasingly important in massively parallel data systems.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/ARIES.pdf">ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>: The first algorithm that actually works: it supports concurrent execution of transactions without losing data even in the presence of failures. This paper is very hard to read because it mixes a lot of low level details in the explanation of the high level algorithm. Perhaps try understand ARIES (log recovery) by reading a database textbook before attempting to read this paper.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/B-tree.pdf">Efficient  Locking for Concurrent Operations on B-Trees</a> and <a href="http://www.cs.berkeley.edu/~rxin/db-papers/R-tree.pdf">The R*-tree:
An Efficient and Robust Access Method for Points and Rectangles</a>: B-Tree is a core data structure in databases (not just relational). It is optimized and has a low read amplification factor for random lookups of on-disk data. R-tree is an extension of B-tree to support lookups of multi-dimensional data, e.g. geodata.</p>

<p><a href="http://www.cs.duke.edu/courses/spring03/cps216/papers/oneil-quass-1997.pdf">Improved Query Performance with Variant Indexes</a>: Analytical databases and OLTP databases require different trade-offs. These are reflected in the choices of indexing data structures. This paper talks about a number of index data structures more suitable for analytical databases.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/OCC-Optimistic-Concurrency-Control.pdf">On Optimistic Methods for Concurrency Control</a>: There are two ways to support concurrency. The first is the pessimistic way, i.e. to lock shared data preemptively. This paper explains an alternatively to locking called Optimistic Concurrency Control. Optimistic approaches assume conflicts are rare and executes transactions without acquiring locks. Before committing the transactions, the database system checks for conflicts and aborts/restarts transactions if conflicts arise.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/SystemR-Optimizer.pdf">Access Path Selection in a Relational Database Management System</a>: The basics of query optimization. SQL is declarative, i.e. you specify using a query language what data you want, not how you want it. There are usually multiple ways (query plans) of executing a query. The database system examines multiple plans and decides on an optimal one (best-effort). This process is called query optimization. The traditional way of doing query optimization is to have a cost-model for different access methods and query plans. This paper explains the cost-model and a dynamic programming algorithm to pick the best plan.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/Eddies.pdf">Eddies: Continuously Adaptive Query Processing</a>: Traditional query optimization (and the cost model used) is static. There are two problems with the traditional model. First, it is hard to build the cost model absent of data statistics. Second, query execution environment might change in long running queries and a static approach cannot capture the change. Analogous to fluid dynamics, this paper proposes a set of techniques that optimize query execution dynamically. I don't think ideas in Eddies have made their way into commercial systems yet, but the paper is very refreshing to read and might become more important now.</p>



<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Systems Design</h3>

<p><a href="http://www.cs.ubc.ca/%7Erap/teaching/504/2010/readings/history-of-system-r.pdf">A History and Evaluation of System R</a>: There were System R from IBM and Ingres from Berkeley, two systems that showed relational database was feasible. This paper describes System R. It is impressive and scary to note that the internals of relational database systems in 2012 look a lot like System R in 1981.</p>

<p><a href="http://research.google.com/archive/gfs.html">The Google File System</a> and <a href="http://research.google.com/archive/bigtable.html">Bigtable: A Distributed Storage System for Structured Data</a>: Two core components of Google's data infrastructure. GFS is an append-only distributed file system for large sequential reads (data-intensive applications). BigTable is high-performance distributed data store that builds on GFS. One way to think about it is that GFS is optimized for high throughput, and BigTable explains how to build a low-latency data store on top of GFS. Some of these might have been replaced by newer proprietary technologies internal to Google, but the ideas stand.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/Chord-DHT.pdf">Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications</a> and <a href="http://www.cs.berkeley.edu/~rxin/db-papers/Dynamo.pdf">Dynamo: Amazon’s Highly Available Key-value Store</a>: Chord was born in the days when distributed hash tables was a hot research. It does one thing, and does it really well: how to look up the location of a key in a completely distributed setting (peer-to-peer) using consistent hashing. The Dynamo paper explains how to build a distributed key-value store using Chord. Note some design decisions change from Chord to Dynamo, e.g. finger table O(logN) vs O(N), because in Dynamo's case, Amazon has more control over nodes in a data center, while Chord assumes peer-to-peer nodes in wide area networks.</p>


<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Columnar Databases</h3>

<p>Columnar storage and column-oriented query engine are critical to analytical workloads, e.g. OLAP.
This section covers a collection of papers describing columnar database systems.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/C-Store.pdf">C-Store: A Column-oriented DBMS</a> and <a href="http://vldb.org/pvldb/vol5/p1790_andrewlamb_vldb2012.pdf">The Vertica Analytic Database: C-Store 7 Years Later</a>: C-Store is an influential, academic system done by the folks in New England. Vertica is the commercial incarnation of C-Store.</p>

<p><a href="http://db.csail.mit.edu/projects/cstore/abadi-sigmod08.pdf">Column-Stores vs. Row-Stores: How Different Are They Really?</a>: Discusses the importance of both the columnar storage and the query engine.</p>

<p><a href="http://research.google.com/pubs/pub36632.html">Dremel: Interactive Analysis of Web-Scale Datasets</a>: A jaw-dropping paper when Google published it. Dremel is a massively parallel analytical database used at Google for ad-hoc queries. The system runs on thousands of nodes to process terabytes of data in seconds. It applies columnar storage to complex, nested data structures. The paper talks a lot about the nested data structure support, and is a bit light on the details of the query execution. Note that a number of open source projects are claiming they are building "Dremel". The Dremel system achieves low-latency through massive parallelism and columnar storage, so the model doesn't necessarily make sense outside Google since very few companies in the world can afford thousands of nodes for ad-hoc queries.</p>

<p><a href="http://vldb.org/pvldb/vol5/p1436_alexanderhall_vldb2012.pdf">Processing a Trillion Cells per Mouse Click</a>: Describes PowerDrill, a column-oriented, in-memory analytical database used at Google.</p>


<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>MapReduce and Data-Parallel Computation</h3>

<p><a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a>: MapReduce is both a programming model (borrowed from an old concept in functional programming) and a system at Google for distributed data-intensive computation. The programming model is so simple yet expressive enough to capture a wide range of programming needs. The system, coupled with the model, is fault-tolerant and scalable. It is probably fair to say that half of the academia are now working on problems heavily influenced by MapReduce.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/Spark.pdf">Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a>: This is the research paper behind the Spark cluster computing project at Berkeley. Spark exposes a distributed memory abstraction called RDD, which is an immutable collection of records distributed across a cluster's memory. RDDs can be transformed using MapReduce style computations. The RDD abstraction can be orders of magnitude more efficient for workloads that exhibit strong temporal locality, e.g. query processing and iterative machine learning.
Spark is an example of why it is important to separate the MapReduce programming model from its execution engine.</p>

<p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-214">Shark: SQL and Rich Analytics at Scale</a>: Describes the Shark system, which is the SQL engine built on top of Spark. More importantly, the paper discusses why previous MapReduce query engines were slow.</p>

<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Trends (Cloud Computing, Warehouse-scale Computing, New Hardware)</h3>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/cloudcomputing.pdf">A View of Cloud Computing</a>: This paper discusses the economics and obstacles of cloud computing (referring to the elasticity of resources, not the consumer-facing "cloud") from a technical perspective. The obstacles presented in this paper will impact design decisions for systems running in the cloud.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/WarehouseScaleComputing.pdf">The Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines</a>: Google's Luiz André Barroso and Urs Hölzle explains the basics of data center hardware and software for warehouse-scale computing. There is an <a href="http://dl.acm.org/citation.cfm?id=2019527&bnc=1">accompanying video</a>. The video talks about the importance of cutting long-tail latency in massively parallel systems. The other key idea is the disaggregation of resources. Technologies such as GFS/HDFS already disaggregate disks because of high network bandwidth, but yet to see the same trend applying to DRAMs because that'd require low-latency networking.</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/CAP.pdf">CAP Twelve Years Later: How the "Rules" Have Changed</a>: The CAP theorem, proposed by Eric Brewer, asserts that any net­worked shared-data system can have only two of three desirable properties: Consistency, Availability, and Partition-Tolerance. A number of NoSQL stores reference CAP to justify their decision to sacrifice consistency. This is Eric Brewer's writeup on CAP in retrospective, explaining "'2 of 3' formulation was always misleading because it tended to oversimplify the tensions among properties."</p>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/SSD.pdf">Performance Modeling and Analysis of Flash-based Storage Devices</a></p>

<p>Note: I am looking for a good paper to cover GPUs. Any suggestions?</p>


<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Miscellaneous</h3>

<p><a href="http://www.cs.berkeley.edu/~rxin/db-papers/TrustingTrust-Thompson.pdf">Reflections on Trusting Trust</a>:
Ken Thompson's Turing Award acceptance speech in 1984, describing black box backdoor issues and pointing out trust is not absolute.
</p>


<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<!--- ############################################################ -->
<h3>Database Reading Lists</h3>
<p>A number of schools have their own reading lists for graduate students in databases.</p>
<ul>
<li>Berkeley: <a href="http://www.eecs.berkeley.edu/GradAffairs/CS/Prelims/db.html">http://www.eecs.berkeley.edu/GradAffairs/CS/Prelims/db.html</a>
</li>
<li>Brown: <a href="http://www.cs.brown.edu/courses/cs227/papers.html">http://www.cs.brown.edu/courses/cs227/papers.html</a></li>
<li>Stanford: <a href="http://infolab.stanford.edu/db_pages/infoqual.html">http://infolab.stanford.edu/db_pages/infoqual.html</a>
</li>
<li>Wisconsin: <a href="http://www.cs.wisc.edu/sites/default/files/db.reading.pdf">http://www.cs.wisc.edu/sites/default/files/db.reading.pdf</a>
</li>
</ul>
      </section>

      <footer>
        <p>This list is maintained by <a href="http://rxin.org">rxin@cs.berkeley.edu</a> (<a href="https://twitter.com/#!/rxin">@rxin</a>)</p>
        <p><small>Theme modified from <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-7966001-6");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>